package com.regtab.core.rtl.interpreter;

import lombok.NonNull;

import com.regtab.core.model.*;

import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import com.regtab.core.rtl.parser.*;
import org.apache.commons.lang3.StringEscapeUtils;

import static com.regtab.core.rtl.interpreter.RTLPattern.*;
import static com.regtab.core.rtl.parser.RTLParser.*;

/**
 * The Interpreter class is responsible for compiling and interpreting a parse tree generated by an ANTLR parser.
 * It contains nested static classes, each of which is a visitor for a different part of the parse tree.
 */
final class Interpreter {
    /**
     * Compiles the given parse tree into a TablePattern.
     *
     * @param tree The parse tree to compile.
     * @return The compiled TablePattern.
     */
    static TablePattern compile(@NonNull ParseTree tree) {
        return tableVisitor.visit(tree);
    }

    // Private constructor to prevent instantiation
    private Interpreter() {
    }

    // Visitors
    private static final TableVisitor tableVisitor = new TableVisitor();
    private final static SubtableVisitor subtableVisitor = new SubtableVisitor();
    private static final RowVisitor rowVisitor = new RowVisitor();
    private static final SubrowVisitor subrowVisitor = new SubrowVisitor();
    private static final CellVisitor cellVisitor = new CellVisitor();

    private static final ComponentVisitor componentVisitor = new ComponentVisitor();
    private static final StructVisitor structVisitor = new StructVisitor();
    private static final ChoiceVisitor choiceVisitor = new ChoiceVisitor();

    private static final CondVisitor condVisitor = new CondVisitor();
    private static final QuantifierVisitor quantifierVisitor = new QuantifierVisitor();
    private static final ActionVisitor actionVisitor = new ActionVisitor();
    private static final ExprVisitor exprVisitor = new ExprVisitor();

    /**
     * The TableVisitor is responsible for visiting the TableContext and generating a TablePattern.
     */
    final static class TableVisitor extends RTLBaseVisitor<TablePattern> {
        @Override
        public TablePattern visitTable(TableContext ctx) {
            final List<SubtableContext> subtableCtxList = ctx.subtable();

            if (subtableCtxList == null || subtableCtxList.isEmpty())
                return null; // Impossible

            final TablePattern pattern = new TablePattern(ctx);
            for (SubtableContext subtableCtx : subtableCtxList) {
                final SubtablePattern subtablePattern = subtableVisitor.visit(subtableCtx);
                if (subtablePattern == null)
                    return null; // Impossible
                pattern.add(subtablePattern);
            }
            final List<SubtablePattern> subtablePatterns = pattern.getSubtablePatterns();
            return subtablePatterns.isEmpty() ? null : pattern;
        }
    }

    /**
     * The SubtableVisitor is responsible for visiting the SubtableContext and generating a SubtablePattern.
     */
    final static class SubtableVisitor extends RTLBaseVisitor<SubtablePattern> {
        @Override
        public SubtablePattern visitSubtable(SubtableContext ctx) {
            final SubtablePattern subtablePattern = new SubtablePattern(ctx);

            final List<RowContext> rowContexts = ctx.row();
            if (rowContexts != null && !rowContexts.isEmpty()) {
                final boolean result = apply(rowContexts, subtablePattern);
                if (!result)
                    return null; // Impossible

                return subtablePattern;
            }

            final RowsContext rowsContext = ctx.rows();
            if (rowsContext != null) {
                final boolean result = apply(rowsContext, subtablePattern);
                if (!result)
                    return null; // Impossible

                return subtablePattern;
            }

            return null; // Impossible
        }

        private boolean apply(List<RowContext> rowContexts, SubtablePattern pattern) {
            for (RowContext ctx : rowContexts) {
                RowPattern rowPattern = rowVisitor.visit(ctx);
                if (rowPattern == null)
                    return false; // Impossible

                pattern.add(rowPattern);
            }

            final Quantifier quantifier = new Quantifier(Quantifier.Times.UNDEFINED, null);
            pattern.setQuantifier(quantifier);

            return true;
        }

        private boolean apply(RowsContext rowsContext, SubtablePattern pattern) {
            pattern.rowsContext = rowsContext;

            // Instruction order matter
            final List<RowContext> rowContexts = rowsContext.row();
            for (RowContext ctx : rowContexts) {
                RowPattern rowPattern = rowVisitor.visit(ctx);
                if (rowPattern == null)
                    return false; // Impossible
                pattern.add(rowPattern);
            }

            final CondContext condContext = rowsContext.cond();
            if (condContext != null) {
                final Condition condition = condVisitor.visit(condContext);
                if (condition == null)
                    return false; // Impossible

                pattern.setCondition(condition);
            }

            final Quantifier quantifier;
            final QuantifierContext quantifierContext = rowsContext.quantifier();
            if (quantifierContext == null) {
                quantifier = new Quantifier(Quantifier.Times.UNDEFINED, null);
            } else {
                quantifier = quantifierVisitor.visit(quantifierContext);
                if (quantifier == null)
                    return false; // Impossible
            }
            pattern.setQuantifier(quantifier);

            final ActionsContext actionsCtx = rowsContext.actions();
            if (actionsCtx != null) {
                final List<ActionContext> actionCtxList = actionsCtx.action();
                if (actionCtxList != null) {
                    for (ActionContext actionCtx : actionCtxList) {
                        Action action = actionVisitor.visit(actionCtx);
                        if (action == null)
                            return false; // Impossible
                        pattern.add(action);
                    }
                }
            }

            return true;
        }
    }

    /**
     * The RowVisitor is responsible for visiting the RowContext and generating a RowPattern.
     */
    final static class RowVisitor extends RTLBaseVisitor<RowPattern> {
        private static final HashMap<String, SubrowsContext> store = new HashMap<>();

        @Override
        public RowPattern visitRow(RowContext ctx) {
            final RowPattern rowPattern = new RowPattern(ctx);

            final SubrowsContext subrowsContext;
            final CopyContext copyContext = ctx.copy();
            if (copyContext != null) {
                final String label = copyContext.TAG().getText();
                subrowsContext = store.get(label);
                if (subrowsContext == null) {
                    final String msg = String.format("undefined label \"%s\"", label);
                    throw new RTLSyntaxException(msg, ctx);
                }
            } else {
                subrowsContext = ctx.subrows();
            }

            final LabelContext labelContext = ctx.label();
            if (labelContext != null) {
                String label = labelContext.TAG().getText();
                store.put(label, subrowsContext);
            }

            rowPattern.subrowsContext = subrowsContext;

            // Instruction order matter
            final List<SubrowContext> subrowContexts = subrowsContext.subrow();
            for (SubrowContext subrowContext : subrowContexts) {
                final SubrowPattern subrowPattern = subrowVisitor.visit(subrowContext);
                rowPattern.add(subrowPattern);
            }

            final CondContext condContext = subrowsContext.cond();
            if (condContext != null) {
                final Condition condition = condVisitor.visit(condContext);
                rowPattern.setCondition(condition);
            }

            final QuantifierContext quantifierContext = ctx.quantifier();
            final Quantifier quantifier;
            if (quantifierContext != null)
                quantifier = quantifierVisitor.visit(quantifierContext);
            else
                quantifier = new Quantifier(Quantifier.Times.UNDEFINED, null);

            rowPattern.setQuantifier(quantifier);

            final ActionsContext actionsCtx = subrowsContext.actions();
            if (actionsCtx != null) {
                List<ActionContext> actionCtxList = actionsCtx.action();
                if (actionCtxList != null) {
                    for (ActionContext actionCtx : actionCtxList) {
                        Action action = actionVisitor.visit(actionCtx);
                        if (action == null)
                            return null; // Impossible
                        rowPattern.add(action);
                    }
                }
            }

            return rowPattern;
        }

    }

    /**
     * The SubrowVisitor is responsible for visiting the SubrowContext and generating a SubrowPattern.
     */
    final static class SubrowVisitor extends RTLBaseVisitor<SubrowPattern> {
        @Override
        public SubrowPattern visitSubrow(SubrowContext ctx) {
            final SubrowPattern subrowPattern = new SubrowPattern(ctx);

            final List<CellContext> cellContexts = ctx.cell();
            if (cellContexts != null && !cellContexts.isEmpty()) {
                boolean result = apply(cellContexts, subrowPattern);
                if (!result)
                    return null; // Impossible

                return subrowPattern;
            }

            final CellsContext cellsContext = ctx.cells();
            if (cellsContext != null) {
                boolean result = apply(cellsContext, subrowPattern);
                if (!result)
                    return null; // Impossible

                return subrowPattern;
            }

            return null; // Impossible
        }

        private boolean apply(List<CellContext> cellContexts, SubrowPattern pattern) {
            for (CellContext ctx : cellContexts) {
                CellPattern cellPattern = cellVisitor.visit(ctx);
                if (cellPattern == null)
                    return false; // Impossible

                pattern.add(cellPattern);
            }

            final Quantifier quantifier = new Quantifier(Quantifier.Times.UNDEFINED, null);
            pattern.setQuantifier(quantifier);

            return true;
        }

        private boolean apply(CellsContext cellsContext, SubrowPattern pattern) {
            pattern.cellsContext = cellsContext;

            // Instruction order matter
            final List<CellContext> cellContexts = cellsContext.cell();
            for (CellContext ctx : cellContexts) {
                CellPattern cellPattern = cellVisitor.visit(ctx);
                if (cellPattern == null)
                    return false; // Impossible

                pattern.add(cellPattern);
            }

            final CondContext condContext = cellsContext.cond();
            if (condContext != null) {
                final Condition condition = condVisitor.visit(condContext);
                if (condition == null)
                    return false; // Impossible

                pattern.setCondition(condition);
            }

            final Quantifier quantifier;
            final QuantifierContext quantifierContext = cellsContext.quantifier();
            if (quantifierContext == null) {
                quantifier = new Quantifier(Quantifier.Times.UNDEFINED, null);
            } else {
                quantifier = quantifierVisitor.visit(quantifierContext);
                if (quantifier == null)
                    return false; // Impossible
            }
            pattern.setQuantifier(quantifier);

            final ActionsContext actionsCtx = cellsContext.actions();
            if (actionsCtx != null) {
                List<ActionContext> actionCtxList = actionsCtx.action();
                if (actionCtxList != null) {
                    for (ActionContext actionCtx : actionCtxList) {
                        Action action = actionVisitor.visit(actionCtx);
                        if (action == null)
                            return false; // Impossible
                        pattern.add(action);
                    }
                }
            }

            return true;
        }

    }

    /**
     * The CellVisitor is responsible for visiting the CellContext and generating a CellPattern.
     */
    final static class CellVisitor extends RTLBaseVisitor<CellPattern> {
        private static final HashMap<String, ComponentsContext> store = new HashMap<>();

        @Override
        public CellPattern visitCell(CellContext ctx) {
            final CellPattern cellPattern = new CellPattern(ctx);

            final ComponentsContext componentsContext;
            final CopyContext copyContext = ctx.copy();
            if (copyContext != null) {
                String label = copyContext.TAG().getText();
                componentsContext = store.get(label);
                if (componentsContext == null) {
                    final String msg = String.format("undefined label \"%s\"", label);
                    throw new RTLSyntaxException(msg, ctx);
                }
            } else {
                componentsContext = ctx.components();
            }

            final LabelContext labelContext = ctx.label();
            if (labelContext != null) {
                String label = labelContext.TAG().getText();
                store.put(label, componentsContext);
            }

            final boolean result = apply(cellPattern, componentsContext);
            if (!result)
                return null; // Impossible

            final CondContext condContext = componentsContext.cond();
            if (condContext != null) {
                final Condition condition = condVisitor.visit(condContext);
                cellPattern.setCondition(condition);
            }

            final QuantifierContext quantifierContext = ctx.quantifier();
            final Quantifier quantifier;
            if (quantifierContext != null)
                quantifier = quantifierVisitor.visit(quantifierContext);
            else
                quantifier = new Quantifier(Quantifier.Times.UNDEFINED, null);

            cellPattern.setQuantifier(quantifier);

            final ActionsContext actionsCtx = componentsContext.actions();
            if (actionsCtx != null) {
                List<ActionContext> actionCtxList = actionsCtx.action();
                if (actionCtxList != null) {
                    for (ActionContext actionCtx : actionCtxList) {
                        Action action = actionVisitor.visit(actionCtx);
                        if (action == null)
                            return null; // Impossible
                        cellPattern.add(action);
                    }
                }
            }

            return cellPattern;
        }

        private boolean apply(CellPattern pattern, ComponentsContext ctx) {
            final ComponentContext componentContext = ctx.component();
            if (componentContext != null) {
                final ComponentPattern componentPattern = componentVisitor.visit(componentContext);
                if (componentPattern == null)
                    return false; // Impossible

                pattern.setComponentsPattern(componentPattern);
                return true;
            }

            final StructContext structuredContext = ctx.struct();
            if (structuredContext != null) {
                final StructPattern structPattern = structVisitor.visit(structuredContext);
                if (structPattern == null)
                    return false; // Impossible

                pattern.setComponentsPattern(structPattern);
                return true;
            }

            final ChoiceContext choiceContext = ctx.choice();
            if (choiceContext != null) {
                final ChoicePattern choicePattern = choiceVisitor.visit(choiceContext);
                if (choicePattern == null)
                    return false; // Impossible

                pattern.setComponentsPattern(choicePattern);
            }

            return true;
        }

    }

    /**
     * The ComponentVisitor is responsible for visiting the ComponentContext and generating an ComponentPattern.
     */
    final static class ComponentVisitor extends RTLBaseVisitor<ComponentPattern> {
        @Override
        public ComponentPattern visitComponent(ComponentContext ctx) {
            final ComponentTypeContext etCtx = ctx.componentType();

            final Component.Type componentType;
            if (etCtx.VALUE() != null)
                componentType = Component.Type.VALUE;
            else if (etCtx.ATTRIBUTE() != null)
                componentType = Component.Type.ATTRIBUTE;
            else if (etCtx.SKIPPED() != null)
                componentType = Component.Type.SKIPPED;
            else
                componentType = null; // Impossible

            final ComponentPattern componentPattern = new ComponentPattern(ctx);
            componentPattern.setComponentType(componentType);

            final ExprContext exprContext = ctx.expr();
            if (exprContext != null) {
                final Expr expr = exprVisitor.visit(exprContext);
                if (expr == null)
                    return null; // Impossible
                componentPattern.setExpr(expr);
            }

            final TagsContext tagsCtx = ctx.tags();
            if (tagsCtx != null) {
                final List<TerminalNode> tns = tagsCtx.TAG();
                for (TerminalNode tn : tns) {
                    String tag = tn.getText();
                    componentPattern.add(tag);
                }
            }

            final ActionsContext actionsCtx = ctx.actions();
            if (actionsCtx != null) {
                final List<ActionContext> actionCtxList = actionsCtx.action();
                if (actionCtxList != null) {
                    for (ActionContext actionCtx : actionCtxList) {
                        final Action action = actionVisitor.visit(actionCtx);
                        if (action == null)
                            return null; // Impossible
                        componentPattern.add(action);
                    }
                }
            }

            return componentPattern;

        }
    }

    /**
     * The StructVisitor is responsible for visiting the StructContext and generating a StructPattern.
     */
    final static class StructVisitor extends RTLBaseVisitor<StructPattern> {
        @Override
        public StructPattern visitStruct(StructContext ctx) {
            final StructPattern structPattern = new StructPattern(ctx);

            final List<ComponentContext> componentContexts = ctx.component();
            for (ComponentContext compCtx : componentContexts) {
                final ComponentPattern componentPattern = componentVisitor.visit(compCtx);
                if (componentPattern == null)
                    return null; // Impossible

                structPattern.add(componentPattern);
            }

            final StartTextContext stCtx = ctx.startText();
            if (stCtx != null) {
                final String startText = unquote(stCtx.STRING().getText());
                structPattern.setStartText(startText);
            }

            final EndTextContext etCtx = ctx.endText();
            if (etCtx != null) {
                final String endText = unquote(etCtx.STRING().getText());
                structPattern.setEndText(endText);
            }

            final List<SeparatorContext> separatorContexts = ctx.separator();
            if (separatorContexts != null && !separatorContexts.isEmpty()) {
                final List<String> separators = new ArrayList<>(separatorContexts.size());
                for (SeparatorContext separatorContext : separatorContexts) {
                    String separator = unquote(separatorContext.STRING().getText());
                    String unescapedSeparator = StringEscapeUtils.unescapeJava(separator);
                    separators.add(unescapedSeparator);
                }
                structPattern.setSeparators(separators);
            }

            return structPattern;
        }

    }

    /**
     * The ChoiceVisitor is responsible for visiting the ChoiceContext and generating a ChoicePattern.
     */
    final static class ChoiceVisitor extends RTLBaseVisitor<ChoicePattern> {
        @Override
        public ChoicePattern visitChoice(ChoiceContext ctx) {
            final ChoicePattern choicePattern = new ChoicePattern(ctx);

            ChoiceBodyContext choiceBodyContext;

            choiceBodyContext = ctx.choiceBody(0);
            final ComponentsPattern left = createVariant(choiceBodyContext);
            if (left == null)
                return null; // Impossible
            choicePattern.setLeft(left);

            choiceBodyContext = ctx.choiceBody(1);
            final ComponentsPattern right = createVariant(choiceBodyContext);
            if (right == null)
                return null; // Impossible
            choicePattern.setRight(right);

            final CondContext condContext = ctx.cond();
            if (condContext != null) {
                final Condition condition = condVisitor.visit(condContext);
                if (condition == null)
                    return null; // Impossible
                choicePattern.setCondition(condition);
            }

            return choicePattern;
        }

        private ComponentsPattern createVariant(ChoiceBodyContext ctx) {
            final ComponentContext componentContext = ctx.component();
            if (componentContext != null) {
                return componentVisitor.visit(componentContext);
            }

            final StructContext structuredContext = ctx.struct();
            if (structuredContext != null) {
                return structVisitor.visit(structuredContext);
            }

            return null; // Impossible
        }

    }

    /**
     * The CondVisitor is responsible for visiting the CondContext and generating a Condition.
     */
    final static class CondVisitor extends RTLBaseVisitor<Condition> {
        @Override
        public Condition visitCond(CondContext ctx) {
            final Condition cond = new Condition();
            final List<ExprContext> exprCtxList = ctx.expr();

            for (ExprContext exprCtx : exprCtxList) {
                final Expr expr = exprVisitor.visit(exprCtx);

                if (expr == null)
                    return null; // Impossible

                final Constraint constr = new Constraint(expr);
                cond.addConstraint(constr);
            }

            return cond;
        }
    }

    /**
     * The QuantifierVisitor is responsible for visiting the QuantifierContext and generating a Quantifier.
     */
    final static class QuantifierVisitor extends RTLBaseVisitor<Quantifier> {
        public Quantifier visit(QuantifierContext ctx) {
            return visitQuantifier(ctx);
        }

        @Override
        public Quantifier visitQuantifier(QuantifierContext ctx) {
            Quantifier.Times times = null;
            Integer exactly = null;

            if (ctx != null) {
                ExactlyContext exactlyCtx = ctx.exactly();
                if (exactlyCtx != null) {
                    TerminalNode tn = exactlyCtx.INT();
                    times = Quantifier.Times.EXACTLY;
                    String str = tn.getText();
                    exactly = Integer.parseInt(str);
                    if (exactly < 0) {
                        return null; // Impossible
                    }
                } else {
                    if (ctx.oneOrMore() != null)
                        times = Quantifier.Times.ONE_OR_MORE;
                    if (ctx.zeroOrMore() != null)
                        times = Quantifier.Times.ZERO_OR_MORE;
                    if (ctx.zeroOrOne() != null)
                        times = Quantifier.Times.ZERO_OR_ONE;
                }
            } else {
                times = Quantifier.Times.UNDEFINED;
            }

            return new Quantifier(times, exactly);
        }
    }

    /**
     * The ActionVisitor is responsible for visiting the ActionContext and generating an Action.
     */
    final static class ActionVisitor extends RTLBaseVisitor<Action> {
        private static final LookupVisitor lookupVisitor = new LookupVisitor();

        @Override
        public Action visitAction(ActionContext ctx) {
            final List<ActionBodyContext> actionBodyCtxList = ctx.actionBody();
            final ActionTypeContext actionTypeCtx = ctx.actionType();

            final Action.Type actType;

            if (actionTypeCtx.FACTOR() != null)
                actType = Action.Type.FACTOR;
            else if (actionTypeCtx.PREFIX() != null)
                actType = Action.Type.PREFIX;
            else if (actionTypeCtx.SUFFIX() != null)
                actType = Action.Type.SUFFIX;
            else if (actionTypeCtx.RECORD() != null)
                actType = Action.Type.RECORD;
            else if (actionTypeCtx.JOIN() != null)
                actType = Action.Type.JOIN;
            else if (actionTypeCtx.SCHEMA() != null)
                actType = Action.Type.SCHEMA;
            else
                return null; // Impossible

            final Action action = new Action(actType);

            final Configurator configurator = getConfigurator();
            if (configurator != null) {
                final String concatSeparator = configurator.getConcatSeparator();
                action.setConcatSeparator(concatSeparator);

                final String avSeparator = configurator.getAvSeparator();
                action.setAvSeparator(avSeparator);
            }

            if (actionBodyCtxList == null)
                return null; // Impossible

            for (ActionBodyContext actionBodyCtx : actionBodyCtxList) {
                final TerminalNode tn = actionBodyCtx.STRING();

                if (tn != null) {
                    final String string = unquote(tn.getText());
                    action.addString(string);
                } else {
                    final LookupContext lookupCtx = actionBodyCtx.lookup();
                    final Lookup lookup = lookupVisitor.visit(lookupCtx);
                    if (lookup == null)
                        return null; // Impossible
                    action.addLookup(lookup);
                }
            }

            return action;
        }
    }

    /**
     * The LookupVisitor is responsible for visiting the LookupContext and generating a Lookup.
     */
    final static class LookupVisitor extends RTLBaseVisitor<Lookup> {
        @Override
        public Lookup visitLookup(LookupContext ctx) {
            final DirectionContext directionCtx = ctx.direction();
            final Lookup.Direction direction;

            if (directionCtx.LEFT() != null)
                direction = Lookup.Direction.LEFT;
            else if (directionCtx.RIGHT() != null)
                direction = Lookup.Direction.RIGHT;
            else if (directionCtx.UP() != null)
                direction = Lookup.Direction.UP;
            else if (directionCtx.DOWN() != null)
                direction = Lookup.Direction.DOWN;
            else if (directionCtx.IN_ROW() != null)
                direction = Lookup.Direction.IN_ROW;
            else if (directionCtx.IN_COL() != null)
                direction = Lookup.Direction.IN_COL;
            else if (directionCtx.IN_CELL() != null)
                direction = Lookup.Direction.IN_CELL;
            else
                return null; // Impossible

            final Lookup lookup = new Lookup(direction);

            final LimitContext limitCtx = ctx.limit();
            if (limitCtx != null) {
                final String str = limitCtx.INT().getText();
                final int limit = Integer.parseInt(str);
                if (limit <  1)
                    throw new RTLSyntaxException("Limit should be more than 1", ctx);
                lookup.setLimit(limit);
            }

            final WhereContext whereCtx = ctx.where();

            if (whereCtx != null) {
                final RangeContext rangeCtx = whereCtx.range();

                if (rangeCtx != null) {
                    final RowRangeContext rowRangeCtx = rangeCtx.rowRange();
                    if (rowRangeCtx != null) {
                        final Range.Desc rowRangeDesc = new Range.Desc(true);
                        final RangeBodyContext rbCtx = rowRangeCtx.rangeBody();
                        apply(rowRangeDesc, rbCtx);
                        lookup.setRowRangeDesc(rowRangeDesc);
                    }
                    final ColRangeContext colRangeCtx = rangeCtx.colRange();
                    if (colRangeCtx != null) {
                        final RangeBodyContext rbCtx = colRangeCtx.rangeBody();
                        final Range.Desc colRangeDesc = new Range.Desc(false);
                        apply(colRangeDesc, rbCtx);
                        lookup.setColRangeDesc(colRangeDesc);
                    }
                }

                final ComponentIndexContext componentIndexContext = whereCtx.componentIndex();
                if (componentIndexContext != null) {
                    final TerminalNode tn = componentIndexContext.INT();
                    final int index = Integer.parseInt(tn.getText());
                    lookup.setComponentIndex(index);
                }

                final TagsContext tagsCtx = whereCtx.tags();
                if (tagsCtx != null) {
                    final List<TerminalNode> tns = tagsCtx.TAG();
                    for (TerminalNode tn : tns) {
                        String tag = tn.getText();
                        lookup.addTag(tag);
                    }
                }
            }

            final CondContext condCtx = ctx.cond();
            if (condCtx != null) {
                final Condition cond = condVisitor.visit(condCtx);
                if (cond == null)
                    return null; // Impossible
                lookup.setCondition(cond);
            }

            return lookup;
        }

        private void apply(final Range.Desc rangeDesc, RangeBodyContext ctx) {
            int start;
            int end;
            boolean useRelativeStart = false;
            boolean useRelativeEnd = false;

            String literal;
            RelativeContext relativeContext;

            final TerminalNode tn = ctx.INT();
            if (tn != null) {
                literal = tn.getText();
                start = end = Integer.parseInt(literal);
                relativeContext = ctx.relative();
                if (relativeContext != null) {
                    useRelativeStart = useRelativeEnd = true;
                    final TerminalNode minus = relativeContext.MINUS();
                    if (minus != null) {
                        start = -start;
                        end = -end;
                    }
                }
            } else {
                final StartContext startCtx = ctx.start();
                literal = startCtx.INT().getText();
                start = Integer.parseInt(literal);
                relativeContext = startCtx.relative();
                if (relativeContext != null) {
                    useRelativeStart = true;
                    final TerminalNode minus = relativeContext.MINUS();
                    if (minus != null) {
                        start = -start;
                    }
                }

                final EndContext endCtx = ctx.end();
                literal = endCtx.INT().getText();
                end = Integer.parseInt(literal);
                relativeContext = startCtx.relative();
                if (relativeContext != null) {
                    useRelativeEnd = true;
                    final TerminalNode minus = relativeContext.MINUS();
                    if (minus != null) {
                        end = -end;
                    }
                }
            }

            rangeDesc.setStart(start);
            rangeDesc.setUseRelativeStart(useRelativeStart);
            rangeDesc.setEnd(end);
            rangeDesc.setUseRelativeEnd(useRelativeEnd);
        }

    }

    /**
     * The ExprVisitor is responsible for visiting the ExprContext and generating an Expr.
     */
    final static class ExprVisitor extends RTLBaseVisitor<Expr> {
        @Override
        public Expr visitIntLiteral(IntLiteralContext ctx) {
            final String str = ctx.INT().getText();
            final Integer num = Integer.valueOf(str);

            final String text = ctx.getText();
            return Expr.builder().asString(text).integer(num).build();
        }

        @Override
        public Expr visitDoubleLiteral(DoubleLiteralContext ctx) {
            final String str = ctx.DOUBLE().getText();
            final Double num = Double.valueOf(str);

            final String text = ctx.getText();
            return Expr.builder().asString(text).doubl(num).build();
        }

        @Override
        public Expr visitProp(PropContext ctx) {
            final String id = ctx.getText();
            final Prop<?> prop = Prop.get(id);

            if (prop == null) {
                final String msg = String.format("undefined property \"%s\"", id);
                throw new RTLSyntaxException(msg, ctx);
            }

            final String text = ctx.getText();
            return Expr.builder().asString(text).prop(prop).build();
        }

        @Override
        public Expr visitPropExpr(PropExprContext ctx) {
            return super.visit(ctx.prop());
        }

        @Override
        public Expr visitFunc(FuncContext ctx) {
            final String id = ctx.ID().getText();
            final Func<?> func = Func.get(id);
            if (func == null) {
                final String msg = String.format("undefined function \"%s\"", id);
                throw new RTLSyntaxException(msg, ctx);
            }

            final List<ArgContext> argCtxList = ctx.arg();
            if (argCtxList != null) {
                for (ArgContext argCtx : argCtxList) {
                    if (argCtx.INT() != null) {
                        final String str = argCtx.INT().getText();
                        final Integer integer = Integer.valueOf(str);
                        func.addArg(integer);
                    } else if (argCtx.STRING() != null) {
                        final String str = unquote(argCtx.STRING().getText());
                        func.addArg(str);
                    }
                }
            }

            final String text = ctx.getText();
            return Expr.builder().asString(text).func(func).build();
        }

        @Override
        public Expr visitFuncExpr(FuncExprContext ctx) {
            return super.visit(ctx.func());
        }

        @Override
        public Expr visitNotExpr(NotExprContext ctx) {
            final Expr boolExpr = visit(ctx.expr());

            if (boolExpr == null)
                return null; // Impossible

            final String text = ctx.getText();
            return Expr.builder().asString(text).notExpr(boolExpr).build();
        }

        @Override
        public Expr visitParenExpr(ParenExprContext ctx) {
            return visit(ctx.expr());
        }

        @Override
        public Expr visitCompExpr(CompExprContext ctx) {
            final Expr left = this.visit(ctx.leftExpr);
            final Expr right = this.visit(ctx.rightExpr);

            if (left == null || right == null)
                return null; // Impossible

            final String text = ctx.getText();

            if (ctx.op.EQ() != null)
                return Expr.builder()
                        .asString(text)
                        .compOperator(Expr.CompOperator.EQUAL).left(left).right(right)
                        .build();

            if (ctx.op.NEQ() != null)
                return Expr.builder()
                        .asString(text)
                        .compOperator(Expr.CompOperator.NOT_EQUAL).left(left).right(right)
                        .build();

            if (ctx.op.GT() != null)
                return Expr.builder()
                        .asString(text)
                        .compOperator(Expr.CompOperator.GREATER).left(left).right(right)
                        .build();

            if (ctx.op.GE() != null)
                return Expr.builder()
                        .asString(text)
                        .compOperator(Expr.CompOperator.GREATER_OR_EQUAL).left(left).right(right)
                        .build();

            if (ctx.op.LT() != null)
                return Expr.builder()
                        .asString(text)
                        .compOperator(Expr.CompOperator.LESS).left(left).right(right)
                        .build();

            if (ctx.op.LE() != null)
                return Expr.builder()
                        .asString(text)
                        .compOperator(Expr.CompOperator.LESS_OR_EQUAL).left(left).right(right)
                        .build();

            if (ctx.op.CONTAINS() != null)
                return Expr.builder()
                        .asString(text)
                        .compOperator(Expr.CompOperator.CONTAINS).left(left).right(right)
                        .build();

            if (ctx.op.MATCHES() != null)
                return Expr.builder()
                        .asString(text)
                        .compOperator(Expr.CompOperator.MATCHES).left(left).right(right)
                        .build();

            return null; // Impossible
        }

        @Override
        public Expr visitBinaryExpr(BinaryExprContext ctx) {
            final Expr left = this.visit(ctx.leftExpr);
            final Expr right = this.visit(ctx.rightExpr);

            if (left == null || right == null)
                return null; // Impossible

            final String text = ctx.getText();

            if (ctx.op.AND() != null)
                return Expr.builder()
                        .asString(text)
                        .binaryOperator(Expr.BinaryOperator.AND).left(left).right(right)
                        .build();

            if (ctx.op.OR() != null)
                return Expr.builder()
                        .asString(text)
                        .binaryOperator(Expr.BinaryOperator.OR).left(left).right(right)
                        .build();

            return null; // Impossible
        }

        @Override
        public Expr visitArithmExpr(ArithmExprContext ctx) {
            final Expr left = this.visit(ctx.leftExpr);
            final Expr right = this.visit(ctx.rightExpr);

            if (left == null || right == null)
                return null; // Impossible

            final String text = ctx.getText();

            if (ctx.op.PLUS() != null)
                return Expr.builder()
                        .asString(text)
                        .arithmOperator(Expr.ArithmOperator.SUM).left(left).right(right)
                        .build();

            if (ctx.op.MINUS() != null)
                return Expr.builder()
                        .asString(text)
                        .arithmOperator(Expr.ArithmOperator.SUB).left(left).right(right)
                        .build();

            if (ctx.op.MULT() != null)
                return Expr.builder()
                        .asString(text)
                        .arithmOperator(Expr.ArithmOperator.MUL).left(left).right(right)
                        .build();

            if (ctx.op.MOD() != null)
                return Expr.builder()
                        .asString(text)
                        .arithmOperator(Expr.ArithmOperator.MOD).left(left).right(right)
                        .build();

            return null; // Impossible
        }

        @Override
        public Expr visitStrExpr(StrExprContext ctx) {
            final Expr left = this.visit(ctx.leftExpr);
            final Expr right = this.visit(ctx.rightExpr);

            if (left == null || right == null)
                return null; // Impossible

            final String text = ctx.getText();

            if (ctx.op.PLUS() != null)
                return Expr.builder()
                        .asString(text)
                        .strOperator(Expr.StrOperator.CONCAT).left(left).right(right)
                        .build();

            return null; // Impossible
        }

        @Override
        public Expr visitBoolLiteral(BoolLiteralContext ctx) {
            final String text = ctx.getText();

            if (ctx.bool().TRUE() != null)
                return Expr.builder().asString(text).bool(true).build();

            if (ctx.bool().FALSE() != null)
                return Expr.builder().asString(text).bool(false).build();

            return null; // Impossible
        }

        @Override
        public Expr visitStrLiteral(StrLiteralContext ctx) {
            final String str = unquote(ctx.STRING().getText());
            final String unescapedStr = StringEscapeUtils.unescapeJava(str);
            final String text = ctx.getText();

            return Expr.builder().asString(text).string(unescapedStr).build();
        }

        @Override
        public Expr visitHexLiteral(HexLiteralContext ctx) {
            final String hex = ctx.getText().toLowerCase();
            if (!hex.matches("0x[a-f0-9]{6}")) {
                final String msg = String.format("incorrect hexadecimal \"%s\"", hex);
                throw new RTLSyntaxException(msg, ctx);
            }

            final String text = ctx.getText();
            return Expr.builder().asString(text).hex(hex.substring(2)).build();
        }

        @Override
        public Expr visitThisExpr(ThisExprContext ctx) {
            final Expr expr;

            final PropContext propCtx = ctx.prop();
            if (propCtx != null) {
                expr = super.visit(propCtx);
            } else {
                final FuncContext funcCtx = ctx.func();
                if (funcCtx != null)
                    expr = super.visit(funcCtx);
                else
                    return null; // Impossible
            }

            final String text = ctx.getText();
            return expr.toBuilder().asString(text).useCaller(true).build();
        }
    }

    private static String unquote(String string) {
        return string.substring(1, string.length() - 1);
    }
}
